<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GHIElectronics.NETMF.Hardware</name>
    </assembly>
    <members>
        <member name="T:GHIElectronics.NETMF.Hardware.SoftwareI2CBus">
            <summary>
            Master I2C bus functionality implemented in software.
            </summary>
            <remarks>
            This class provides I2C functionality on any two digital pins. It is implemented by toggling the pins using software. It only supports one master on the same bus. Multiple masters on different buses work correctly.<br/>
            <br/>
            You must provide two pins: one for I2C clock and one for I2C data. The user must connect external pull-up resistors on the pins as required for I2C operation.<br/>
            <br/>
            Currently, only 7-bit I2C addresses are supported.<br/>
            Clock rate is currently ignored. Specify 0 for this field. This will make the rate as fast as possible.
            </remarks>
            <example>
            The following example uses two I2C devices on the same bus.<br/>
            <code>
<![CDATA[
using System;
using Microsoft.SPOT;
using Microsoft.SPOT.Hardware;

using GHIElectronics.NETMF.Hardware;

namespace Example
{
    public class Program
    {
        public static void Main()
        {
            // Create the bus
            Cpu.Pin clockPin = Cpu.Pin.GPIO_Pin1; // choose a correct pin here
            Cpu.Pin dataPin = Cpu.Pin.GPIO_Pin2; // choose a correct pin here
            SoftwareI2CBus i2cBus = new SoftwareI2CBus(clockPin, dataPin);

            // Our first device has address 0x52
            SoftwareI2CBus.I2CDevice i2cDevice1 = i2cBus.CreateI2CDevice(0x52, 0);

            // Our second device has address 0x62
            SoftwareI2CBus.I2CDevice i2cDevice2 = i2cBus.CreateI2CDevice(0x62, 0);

            int numWritten;
            int numRead;

            // write some data
            byte [] dataToWrite = new byte[]{0,1,2,3};
            numWritten = i2cDevice1.Write(dataToWrite, 0, dataToWrite.Length);

            // read some data
            byte[] dataToRead = new byte[2];
            numRead = i2cDevice2.Read(dataToRead, 0, dataToRead.Length);

            // write then read data
            bool allDataProcessed = i2cDevice2.WriteRead(dataToWrite, 0, 2, dataToRead, 0, 2, out numWritten, out numRead);
        }

    }
}
]]>
</code>
            </example>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.SoftwareI2CBus.#ctor(Microsoft.SPOT.Hardware.Cpu.Pin,Microsoft.SPOT.Hardware.Cpu.Pin)">
            <summary>
            Creates an I2C bus using the clock and data pins.
            </summary>
            <param name="clockPin">Clock pin.</param>
            <param name="dataPin">Data pin.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.SoftwareI2CBus.CreateI2CDevice(System.UInt16,System.Int32)">
            <summary>
            Creates an I2C device on the bus.
            </summary>
            <param name="address">Address of the device. This must be a 7 bit address.</param>
            <param name="clockRateKHz">Clock rate in KHz. Currently ignored. Specify 0 to go as fast as possible.</param>
            <returns>Created I2C device.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.SoftwareI2CBus.DirectI2CWriteRead(Microsoft.SPOT.Hardware.Cpu.Pin,Microsoft.SPOT.Hardware.Cpu.Pin,System.Int32,System.UInt16,System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Processes I2C directly without creating objects.
            </summary>
            <param name="clockPin">Clock pin.</param>
            <param name="dataPin">Data pin.</param>
            <param name="clockRateKHz">Clock rate in KHz.</param>
            <param name="address">Address of the device.</param>
            <param name="writeBuffer">Write buffer.</param>
            <param name="writeOffset">Offset into the write buffer.</param>
            <param name="writeLength">Number of bytes to write.</param>
            <param name="readBuffer">Read buffer.</param>
            <param name="readOffset">Offset into the read buffer.</param>
            <param name="readLength">Number of bytes to read.</param>
            <param name="numWritten">Number of bytes written successfully.</param>
            <param name="numRead">Number of bytes read successfully.</param>
            <returns><c>true</c> if all the required bytes are written and read successfully.</returns>
            <remarks>
            Do not use this method. It is intended for internal use only. See <c>CreateI2CDevice</c> instead.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.SoftwareI2CBus.Dispose">
            <summary>
            Disposes the I2C bus.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.SoftwareI2CBus.Finalize">
            <exclude/>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.SoftwareI2CBus.I2CDevice">
            <summary>
            Represents an I2C device on a bus.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.SoftwareI2CBus.I2CDevice.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a data buffer to the I2C device.
            </summary>
            <param name="buffer">Buffer.</param>
            <param name="offset">Offset into the buffer.</param>
            <param name="count">Number of bytes to write.</param>
            <returns>Number of bytes sent successfully.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.SoftwareI2CBus.I2CDevice.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a data buffer from the I2C device.
            </summary>
            <param name="buffer">Buffer.</param>
            <param name="offset">Offset into the buffer.</param>
            <param name="count">Number of bytes to read.</param>
            <returns>Number of bytes read successfully.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.SoftwareI2CBus.I2CDevice.WriteRead(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Writes a data buffer then reads a data buffer from the I2C device.
            </summary>
            <param name="writeBuffer">Write buffer.</param>
            <param name="writeOffset">Offset into the write buffer.</param>
            <param name="writeLength">Number of bytes to write.</param>
            <param name="readBuffer">Read buffer.</param>
            <param name="readOffset">Offset into the read buffer.</param>
            <param name="readLength">Number of bytes to read.</param>
            <param name="numWritten">Number of bytes written successfully.</param>
            <param name="numRead">Number of bytes read successfully.</param>
            <returns><c>true</c> if all the required bytes are written and read successfully.</returns>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.LowLevel.Power">
            <summary>
            Power Management Methods.
            </summary>
            <remarks>
            This class provides several methods to manage the power.<br/>
            Important Note: When using waking up upon InterruptInputs activity, the desired InterruptPort must be enabled with glitch filter or has OnInterrupt event assigned.<br/>
            <br/>
            Only available for USBizi and EMX.
            </remarks>
            <example>
            Hibernate and wake up on InterruptPort activity.<br/>
            <code>
<![CDATA[
using System;
using Microsoft.SPOT.Hardware;
using GHIElectronics.NETMF.Hardware;
using GHIElectronics.NETMF.Hardware.LowLevel;
using System.Threading;
namespace Example
{
    public class Program
    {
        public static void Main()
        {
            // Assign an InterruptPort, this pin will wake up the device
            InterruptPort button_Sel = new InterruptPort((Cpu.Pin)30, true, Port.ResistorMode.PullUp, Port.InterruptMode.InterruptEdgeHigh);
            Debug.Print("Hibernate in 5 seconds");
            Thread.Sleep(5000);
            Debug.Print("Hibernating...");
            Power.Hibernate(Power.WakeUpInterrupt.InterruptInputs);

            // Toggle IO30 to wake up the system.
        }
    }
}
]]>
</code>
            Hibernate and wake up on EINT0 activity.
            <code>
<![CDATA[
using System;
using Microsoft.SPOT.Hardware;
using GHIElectronics.NETMF.Hardware;
using GHIElectronics.NETMF.Hardware.LowLevel;
using System.Threading;
namespace Example
{
    public class Program
    {
        public static void Main()
        {
            Debug.Print("Hibernate in 5 seconds");
            Thread.Sleep(5000);
            Debug.Print("Hibernating...");
            Power.Hibernate(Power.WakeUpInterrupt.EINT0);

            // The system wakes up if EINT0 level is Low. (IO0 USBizi or IO23 EMX/Embedded Master)
        }
    }
}
]]>
</code>
            Hibernate and wake up on time alarm signal.
            <code>
<![CDATA[
using System;
using Microsoft.SPOT.Hardware;
using GHIElectronics.NETMF.Hardware;
using GHIElectronics.NETMF.Hardware.LowLevel;
using System.Threading;
namespace Example
{
    public class Program
    {
        public static void Main()
        {
            Debug.Print("Hibernate in 5 seconds");
            Thread.Sleep(5000);
            RealTimeClock.SetTime(new DateTime(2010, 07, 30, 13, 31, 00));
            RealTimeClock.SetAlarm(new DateTime(2010, 07, 30, 13, 31, 10));
            Debug.Print("Hibernating...");
            Power.Hibernate(Power.WakeUpInterrupt.RTCAlarm);

            // The system wakes up in 10 seconds on alarm
        }
    }
}
]]>
</code>
            </example>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.Power.Hibernate(GHIElectronics.NETMF.Hardware.LowLevel.Power.WakeUpInterrupt)">
            <summary>
            Hibernates the system.
            </summary>
            <param name="WakeUpInterrupt">The interrupt(s) desired to wake up the system </param>
            <remarks>
            This method is very useful when power saving is a must. On Hibernate, the processor will turn off completely.<br/>
            You have to specifiy interrupt(s) to wake up the system later.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.Power.EthernetOscillatorEnable(System.Boolean)">
            <summary>
            This method turns off the Ethernet oscillator when Ethernet networking is not used.<br/>
            </summary>
            <param name="state"><c>false</c> to disable the oscillator.</param>
            <remarks>
            On EMX module power savings is about 25mA.
            </remarks>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.LowLevel.Power.WakeUpInterrupt">
            <summary>
            Interrupts that can wake up the system after hibernating.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.LowLevel.Power.WakeUpInterrupt.EINT0">
            <summary>
            External Interrupt 0 (IO0 on USBizi or IO23 on EMX/Embedded Master).
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.LowLevel.Power.WakeUpInterrupt.CAN">
            <summary>
            Activity of the CAN bus.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.LowLevel.Power.WakeUpInterrupt.InterruptInputs">
            <summary>
            Specified activity on any InterruptPort.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.LowLevel.Power.WakeUpInterrupt.BrownOutDetect">
            <summary>
            Brown-Out Detect interrupt.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.LowLevel.Power.WakeUpInterrupt.RTCAlarm">
            <summary>
            Assertion of an RTC alarm interrupt.
            </summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.AnalogIn">
            <summary>
            Provides the ability to read an analog input pin.
            </summary>
            <remarks>
            Please refer to your platform documentation for the available analog pins. The analog pin is initialized with the default platform resolution.<br/>
            <br/>
            <strong style="color:blue">EMX and USBizi</strong><br/>
            Default resolution is 10 bits with analog value between [0, 1023].
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.AnalogIn.Dispose">
            <summary>
            Disposes the pin and marks it as available again.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.AnalogIn.Finalize">
            <exclude/>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.AnalogIn.#ctor(GHIElectronics.NETMF.Hardware.AnalogIn.Pin)">
            <summary>
            Creates a new analog pin.
            </summary>
            <param name="ain">Needed analog pin.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.AnalogIn.SetLinearScale(System.Int32,System.Int32)">
            <summary>
            Scales the analog value when reading automatically into a specific range.
            </summary>
            <param name="minValue">Min value.</param>
            <param name="maxValue">Max value.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.AnalogIn.Read">
            <summary>
            Reads the current analog value.
            </summary>
            <returns>Current analog value.</returns>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.AnalogIn.Pin">
            <summary>
            Lists the analog input pins.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain0">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain1">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain2">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain3">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain4">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain5">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain6">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain7">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain8">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain9">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain10">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain11">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain12">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain13">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain14">
            <summary>Analog input pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogIn.Pin.Ain15">
            <summary>Analog input pin.</summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.InternalFlashStorage">
            <summary>
            Provides internal storage for the user.
            </summary>
            <remarks>
            Only USBizi supports this feature. Other platforms have Extended Weak Reference support which provides similar functionality.<br/>
            <br/>
            The entire data region must be read or written at once. To get the supported region size, use <c>InternalFlashStorage.Size</c>. The size on USBizi is 4 KB.<br/>
            To update a portion of the region only, the user must read the entire region first, update the needed values and then write the entire region back.<br/>
            <br/>
            This is intended to save some custom settings when needed. Writing to the Flash very frequently will reduce its lifetime faster.
            </remarks>
            <example>
            The following will save some data in Flash.
            <code>
<![CDATA[
using System;
using Microsoft.SPOT;

using GHIElectronics.NETMF.Hardware;

namespace Example
{
    public class Program
    {
        public static void Main()
        {
            // create a buffer that is the size of the region first
            byte[] buffer = new byte[InternalFlashStorage.Size];

            // save some data
            buffer[0] = 0x12;
            buffer[1] = 0x34;
            
            // write
            InternalFlashStorage.Write(buffer);
        }

    }
}
]]>
</code>
            </example>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.InternalFlashStorage.Read(System.Byte[])">
            <summary>
            Reads the storage region.
            </summary>
            <param name="data">Data buffer.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.InternalFlashStorage.Write(System.Byte[])">
            <summary>
            Writes the storage region.
            </summary>
            <param name="data">Data buffer.</param>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.InternalFlashStorage.Size">
            <summary>
            Region size.
            </summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.LowLevel.AddressSpace">
            <summary>
            Provides access to the address space.
            </summary>
            <remarks>
            Addresses access might be restricted on certain platforms.<br/>
            <br/>
            <strong style="color:blue">EMX and USBizi</strong><br/>
            Denoting '[' as inclusive and ')' as exclusive, only register access (4 bytes) with the following address ranges are valid:<br/>
            [0x3FFFC000 to 0x3FFFC0A0),<br/>
            [0xE0000000 to 0xE0000014),<br/>
            [0xE0004000 to 0xE004C000),<br/>
            [0xE0068000 to 0xE0090000),<br/>
            [0xE01FC000 to 0xE0200000),<br/>
            [0xFFE00000 to 0xFFE00FF8],<br/>
            [0xFFE0C000 to 0xFFE10000],<br/>
            [0xFFE10000 to 0xFFE10030],<br/>
            [0xFFE10200 to 0xFFE103FC],<br/>
            [0xFFE10800 to 0xFFE10BFC],<br/>
            [0xFFE10C00 to 0xFFE10C2C].<br/>
            <br/>
            <strong style="color:blue">ChipworkX</strong><br/>
            No current restrictions.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.AddressSpace.Write(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a buffer to the target address space.
            </summary>
            <param name="address">Starting address.</param>
            <param name="buffer">Buffer.</param>
            <param name="offset">Offset.</param>
            <param name="count">Count.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.AddressSpace.Read(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the address space into a buffer.
            </summary>
            <param name="address">Starting address.</param>
            <param name="buffer">Buffer.</param>
            <param name="offset">Offset.</param>
            <param name="count">Count.</param>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.Configuration">
            <summary>
            Provides access to some hardware and software configurations.
            </summary>
            <remarks>
            Some of the configurations must only be used by advanced users. If you need to revert to the default settings and you are not able to do so in software, you must download TinyCLR firmware files and possibly TinyBooter again to your hardware. The configurations are normally saved in the config file.<br/>
            Configurations will be saved internally and always used for future reboots, unless otherwise noted.<br/>
            <br/>
            <strong>Note:</strong> You must reset the hardware after you change the settings for them to take effect, unless otherwise noted.<br/>
            </remarks>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.Configuration.TinyBooter">
            <summary>
            Provides some TinyBooter options.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.TinyBooter.DisableApplicationAccess(System.Boolean)">
            <summary>
            Disables managed application access.
            </summary>
            <param name="isDisabled"><c>true</c> to disable it.</param>
            <returns><c>true</c> if configurations where updated. <c>false</c> if configurations did not change.</returns>
            <remarks>
            This is used to disable access to the managed application from TinyBooter. When it is enabled, the application cannot be erased, read or be written to.<br/>
            <br/>
            This is only supported on EMX.
            </remarks>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.Configuration.PermanentUserKey">
            <summary>
            Permanent user stored key.
            </summary>
            <remarks>
            <strong style="color:red">NOTE:</strong> The key is stored in permanent memory. It can only be set once and cannot be erased. The process is critical and any power failures during storing the key may result in permanent damage to your hardware module.<br/>
            <br/>
            Using this class you can store a permanent key on your device. It is just a number of stored bytes and can be used as an ID, serial number...etc. The key can be stored once and cannot be erased (even if you erase all from the bootloader).<br/>
            The number of bytes supported for the key can be obtained from <c>PermanentUserKey.KeyLength</c>. Currently, this value is fixed to 16 bytes.<br/>
            <br/>
            Only supported on EMX and USBizi.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.PermanentUserKey.Get(System.Byte[])">
            <summary>
            Gets the stored key.
            </summary>
            <param name="key">The array must be of size <c>PermanentUserKey.KeyLength</c>.</param>
            <returns><c>true</c> only if the key was stored previously.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.PermanentUserKey.Set(System.Byte[])">
            <summary>
            Stores the key in permanent memory.
            </summary>
            <remarks>
            <strong style="color:red">NOTE:</strong> The key is stored in permanent memory. It can only be set once and cannot be erased. The process is critical and any power failures during storing the key may result in permanent damage to your hardware module.<br/>
            </remarks>
            <param name="key">The array must be of size <c>PermanentUserKey.KeyLength</c>.</param>
            <returns><c>true</c> only if the key was stored successfully. The key can only be stored once and must not contain all 0xFF values for the key bytes.</returns>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.Configuration.PermanentUserKey.KeyLength">
            <summary>
            Supported number of bytes for the key.
            </summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.Configuration.StartUpLogo">
            <summary>
            Startup logo.
            </summary>
            <remarks>
            You can set a custom startup logo for your device. This is saved internally and will be used on every reboot.<br/>
            There are restrictions on the size of the logo, see <c>SupportedWidth</c> and <c>SupportedHeight</c>. This class only accepts a Bitmap byte array which can be generated from <c>myBitmap.GetBitmap()</c>.
            </remarks>
            <example>
            <code>
<![CDATA[
using Microsoft.SPOT;
using Microsoft.SPOT.Presentation;

using GHIElectronics.NETMF.Hardware;

namespace Example
{
    public class Program
    {
        public static void Main()
        {
            // get then logo
            Bitmap logo = Resources.GetBitmap(Resources.BitmapResources.logo);

            // Scale to supported width and height
            Bitmap scaledLogo = new Bitmap(Configuration.StartUpLogo.SupportedWidth, Configuration.StartUpLogo.SupportedHeight);
            scaledLogo.StretchImage(0, 0, logo, scaledLogo.Width, scaledLogo.Height, Bitmap.OpacityOpaque);

            // Set the logo. The logo position will be the lower right corner.
            Configuration.StartUpLogo.Set(scaledLogo.GetBitmap(), SystemMetrics.ScreenWidth - Configuration.StartUpLogo.SupportedWidth, SystemMetrics.ScreenHeight - Configuration.StartUpLogo.SupportedHeight);
        }
    }
}
]]>
</code>
            </example>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.StartUpLogo.Set(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets custom Startup logo.
            </summary>
            <param name="bitmapBytes"><c>Bitmap</c> bytes.</param>
            <param name="destX">Logo x position.</param>
            <param name="destY">Logo y position.</param>
            <returns><c>true</c> if configurations where updated. <c>false</c> if configurations did not change.</returns>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.Configuration.StartUpLogo.Enabled">
            <summary>
            Gets/Sets Startup Logo enable.
            </summary>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.Configuration.StartUpLogo.SupportedWidth">
            <summary>
            Supported Width.
            </summary>
            <remarks>
            Currently fixed to 180.
            </remarks>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.Configuration.StartUpLogo.SupportedHeight">
            <summary>
            Supported Height.
            </summary>
            <remarks>
            Currently fixed to 180.
            </remarks>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.Configuration.Heap">
            <summary>
            Heap configuration.
            </summary>
            <remarks>
            The total heap size is fixed. This includes regular heap size and custom heap size. You can set the custom heap size using <c>Heap.SetCustomHeapSize</c> and the regular heap size will be the total heap size - custom heap size.<br/>
            Regular heap is just the one used by NETMF for allocating memory for objects. Custom heap is a seperate heap that is not fully managed. It is currently used for big Bitmaps, Large Buffer and wear leveling.<br/>
            <br/>
            <strong>Big Bitmaps:</strong> This is needed for large LCDs to allocate bitmaps with needed memory more than 786420 / 2. Note that it is best to Dispose your bitmaps after you are done with them or the custom heap will become full quickly.<br/>
            <strong>Large Buffer:</strong> Please see <c>Microsoft.SPOT.Hardware.LargeBuffer</c>. You can use this to allocate blocks larger than allowed by the managed heap which is about 786420.<br/>
            <strong>Wear Leveling:</strong> Used intenally on storage devices. Currently, it is only used with internal NAND storage on ChipworkX.<br/>
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.Heap.SetCustomHeapSize(System.UInt32)">
            <summary>
            Sets custom heap size.
            </summary>
            <param name="customHeapSize">Size of custom heap.</param>
            <returns><c>true</c> if configurations where updated. <c>false</c> if configurations did not change.</returns>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.Configuration.Heap.TotalHeapSize">
            <summary>
            Total heap size.
            </summary>
            <remarks>
            Includes managed heap size and custom heap size.
            </remarks>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.Configuration.Heap.CurrentManagedHeapSize">
            <summary>
            Current managed heap size.
            </summary>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.Configuration.Heap.CurrentCustomHeapSize">
            <summary>
            Current custom heap size.
            </summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.Configuration.LCD">
            <summary>
            LCD configurations.
            </summary>
            <remarks>
            This class can change the used LCD. You can change the needed display settings to match your LCD requirements.<br/>
            Do not use <c>LCD_Configuration.PriorityEnable</c> unless necessary. It may degrade performance.<br/>
            <br/>
            Note that setting <c>PixelClockDivider</c> to 0xFF will not refresh the LCD and it will be disabled.
            <br/>
            <strong style="color:blue">EMX</strong><br/>
            The LCD Controller Source Clock is 72 MHz. LCD Clock = LCD Controller Source Clock / PixelClockDivider<br/>
            Maximum supported resolution is 800x600.<br/>
            <br/>
            <strong style="color:blue">ChipworkX</strong><br/>
            The LCD Controller Source Clock is 100 MHz. LCD Clock = LCD Controller Source Clock / ((PixelClockDivider + 1) * 2)<br/>
            Maximum supported resolution is 800x600.<br/>
            </remarks>
            <example>
            This is configuration for 4.3" LCD with resolution of 480x272 used on ChipworkX and Embedded Master development systems. Part number: LQ043T1DG01.
            <code>
<![CDATA[
Configuration.LCD.Configurations lcdConfig = new Configuration.LCD.Configurations();

lcdConfig.Width = 480;
lcdConfig.Height = 272;

// Only use if needed, see documentation.
lcdConfig.PriorityEnable = false;

lcdConfig.OutputEnableIsFixed = true;
lcdConfig.OutputEnablePolarity = true;

lcdConfig.HorizontalSyncPolarity = false;
lcdConfig.VerticalSyncPolarity = false;
lcdConfig.PixelPolarity = false;

lcdConfig.HorizontalSyncPulseWidth = 41;
lcdConfig.HorizontalBackPorch = 2;
lcdConfig.HorizontalFrontPorch = 2;
lcdConfig.VerticalSyncPulseWidth = 10;
lcdConfig.VerticalBackPorch = 2;
lcdConfig.VerticalFrontPorch = 2;

// NOTE: This is used for EMX, comment if using ChipworkX.
//lcdConfig.PixelClockDivider = 8;

// NOTE: This is used for ChipworkX, comment if using EMX.
lcdConfig.PixelClockDivider = 4;

// Set configs
Configuration.LCD.Set(lcdConfig);
]]>
</code>
            This is configuration for 3.5" LCD with resolution of 320x240 used on EMX development system. Part number: PT0353224T-A802.
            <code>
<![CDATA[
Configuration.LCD.Configurations lcdConfig = new Configuration.LCD.Configurations();

lcdConfig.Width = 320;
lcdConfig.Height = 240;

// Only use if needed, see documentation.
lcdConfig.PriorityEnable = false;

lcdConfig.OutputEnableIsFixed = true;
lcdConfig.OutputEnablePolarity = true;

lcdConfig.HorizontalSyncPolarity = false;
lcdConfig.VerticalSyncPolarity = false;
lcdConfig.PixelPolarity = true;

lcdConfig.HorizontalSyncPulseWidth = 41;
lcdConfig.HorizontalBackPorch = 27;
lcdConfig.HorizontalFrontPorch = 51;
lcdConfig.VerticalSyncPulseWidth = 10;
lcdConfig.VerticalBackPorch = 8;
lcdConfig.VerticalFrontPorch = 16;

lcdConfig.PixelClockDivider = 8;

// Set config
Configuration.LCD.Set(lcdConfig);
]]>
</code>
            This is configuration for VGA display with resolution of 640x480 (actual timings for 480x480) on EMX.
            <code>
<![CDATA[
Configuration.LCD.Configurations lcdConfig = new Configuration.LCD.Configurations();

lcdConfig.Width = 480;
lcdConfig.Height = 480;

// VGA requires high refresh rate, enable bus priority.
lcdConfig.PriorityEnable = true;

lcdConfig.OutputEnableIsFixed = true;
lcdConfig.OutputEnablePolarity = true;

lcdConfig.HorizontalSyncPolarity = false;
lcdConfig.VerticalSyncPolarity = false;
lcdConfig.PixelPolarity = true;

lcdConfig.HorizontalSyncPulseWidth = 69;
lcdConfig.HorizontalBackPorch = 20;
lcdConfig.HorizontalFrontPorch = 3;
lcdConfig.VerticalSyncPulseWidth = 2;
lcdConfig.VerticalBackPorch = 32;
lcdConfig.VerticalFrontPorch = 11;

lcdConfig.PixelClockDivider = 4;

// Set config
Configuration.LCD.Set(lcdConfig);
]]>
</code>
            </example>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.LCD.SetRotation(GHIElectronics.NETMF.Hardware.Configuration.LCD.Rotation)">
            <summary>
            Changes LCD orientation.
            </summary>
            <param name="rot">Rotation setting.</param>
            <returns><c>true</c> if configurations where updated. <c>false</c> if configurations did not change.</returns>
            <remarks>
            This is used to rotate the LCD. For example, if the LCD need to be viewed from the side or upside down.<br/>
            Typically, an LCD with the needed orientation should be used and this method is not needed. But in cases where the LCD cannot be changed, use this function.<br/>
            Assume an LCD with 320x240 resolution. After rotation 90 degrees, the LCD graphics will be 240x320 instead.<br/>
            <strong>Note</strong> that because of the dimension change, the LCD must NOT be rotated while WPF is active. Typically, the user will set the LCD rotation at startup and then run the WPF application.<br/>
            The change in dimensions and LCD rotation is done in software and consumes CPU processing time when graphics are flushed to the LCD. Therefore, only use it if necessary.<br/>
            Also, when LCD is rotated, touch events are rotated accordingly. You need to set the touch calibration after rotation.<br/>
            <br/>
            For example to rotate 320x240 LCD to output 240x320 graphics,<br/>
            1) Set rotation to CW 90 degrees.<br/>
            2) Start WPF. Dimensions and graphics are 240x320 now.<br/>
            3) Calibrate touch if used.<br/>
            <br/>
            <strong>Note:</strong> Rotation settings are done dynamically; no reboot is needed and they are NOT saved internally. They must be set each time the application starts.
            </remarks>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.HeadlessConfig">
            <summary>
            Choose for headless LCD.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.LCD.EnableLCDBootupMessages(System.Boolean)">
            <summary>
            Enables/Disables LCD bootup messages.
            </summary>
            <param name="IsEnabled"><c>true</c> if messages are enabled.</param>
            <returns><c>true</c> if configurations where updated. <c>false</c> if configurations did not change.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.LCD.Set(GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations)">
            <summary>
            Sets LCD Configuration.
            </summary>
            <param name="config">LCD configuration.</param>
            <returns><c>true</c> if configurations where updated. <c>false</c> if configurations did not change.</returns>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.Configuration.LCD.Rotation">
            <summary>
            Rotation type.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Rotation.Rotate_Normal">
            <summary>Normal.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Rotation.Rotate_CW_90">
            <summary>Rotate clockwise 90 degrees.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Rotation.Rotate_180">
            <summary>Rotate 180 degrees.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Rotation.Rotate_CCW_90">
            <summary>Rotate counterclockwise 90 degrees.</summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations">
            <summary>
            Configurations.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.#ctor(System.UInt32,System.UInt32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Constructor.
            </summary>
            <param name="Width">Resolution width.</param>
            <param name="Height">Resolution height.</param>
            <param name="PriorityEnable">Internal LCD bus priority.</param>
            <param name="OutputEnableIsFixed"><c>true</c> if LCD enable is a fixed state. <c>false</c> if LCD enable is managed by LCD controller.</param>
            <param name="OutputEnablePolarity"><c>true</c> if active state is high.</param>
            <param name="HorizontalSyncPolarity"><c>true</c> if active state is high.</param>
            <param name="VerticalSyncPolarity"><c>true</c> if active state is high.</param>
            <param name="PixelPolarity"><c>true</c> if your LCD clocks data on the rising edge of the LCD clock.</param>
            <param name="HorizontalSyncPulseWidth">Horizontal Sync pulse width in clock cycles.</param>
            <param name="HorizontalBackPorch">Horizontal back porch in clock cycles.</param>
            <param name="HorizontalFrontPorch">Horizontal front porch in clock cycles.</param>
            <param name="VerticalSyncPulseWidth">Vertical Sync pulse width given by number of lines.</param>
            <param name="VerticalBackPorch">Vertical back porch given by number of lines.</param>
            <param name="VerticalFrontPorch">Vertical front porch given by number of lines.</param>
            <param name="PixelClockDivider">Pixel clock divider.</param>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.Width">
            <summary>
            Resolution width.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.Height">
            <summary>
            Resolution height.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.PriorityEnable">
            <summary>
            Internal LCD bus priority.
            </summary>
            <remarks>
            This is only supported on EMX. By setting this flag to true, the LCD controller will get the highest priority for the processor which will significantly reduce the general performance of the system for other processes. This feature is usually used for displays that require very high refresh rates such as VGA displays.
            </remarks>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.OutputEnableIsFixed">
            <summary>
            <c>true</c> if LCD enable is a fixed state. <c>false</c> if LCD enable is managed by LCD controller.
            </summary>
            <remarks>
            For ChipworkX, LCD Enable is PB3. If Enable is fixed, no changes are done for PB3 and it can be used as a regular I/O. If Enable is not fixed, LCD Enable is handled by the LCD controller directly.
            </remarks>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.OutputEnablePolarity">
            <summary>
            <c>true</c> if active state is high.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.HorizontalSyncPolarity">
            <summary>
            <c>true</c> if active state is high.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.VerticalSyncPolarity">
            <summary>
            <c>true</c> if active state is high.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.PixelPolarity">
            <summary>
            <c>true</c> if your LCD clocks data on the rising edge of the LCD clock.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.HorizontalSyncPulseWidth">
            <summary>
            Horizontal Sync pulse width in clock cycles.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.HorizontalBackPorch">
            <summary>
            Horizontal back porch in clock cycles.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.HorizontalFrontPorch">
            <summary>
            Horizontal front porch in clock cycles.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.VerticalSyncPulseWidth">
            <summary>
            Vertical Sync pulse width given by number of lines.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.VerticalBackPorch">
            <summary>
            Vertical back porch given by number of lines.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.VerticalFrontPorch">
            <summary>
            Vertical front porch given by number of lines.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.LCD.Configurations.PixelClockDivider">
            <summary>
            Pixel clock divider.
            </summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.Configuration.DebugInterface">
            <summary>
            Debug interface configurations.
            </summary>
            <remarks>
            You can change the debug interface for TinyBooter and TinyCLR. TinyBooter does NOT support Sockets debugging.<br/>
            This configuration may be overrided by hardware, please refer to your platform user manual.<br/>
            <br/>
            <strong style="color:blue">USBizi</strong><br/>
            Not supported. It can be changed using hardware, please refer to user manual.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.DebugInterface.Set(GHIElectronics.NETMF.Hardware.Configuration.DebugInterface.Port,GHIElectronics.NETMF.Hardware.Configuration.DebugInterface.Port)">
            <summary>
            Sets NETMF debug interface.
            </summary>
            <param name="TinyCLR_DebugInterface">TinyCLR debug interface.</param>
            <param name="TinyBooter_DebugInterface">TinyBooter debug interface.</param>
            <returns><c>true</c> if configurations where updated. <c>false</c> if configurations did not change.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.DebugInterface.GetCurrent">
            <summary>
            Gets the current active debug interface.
            </summary>
            <returns>Current debug interface.</returns>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.Configuration.DebugInterface.Port">
            <summary>
            Lists the available debug interfaces for .Net Micro Framework.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.DebugInterface.Port.COM1">
            <summary>A supported debug interface.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.DebugInterface.Port.COM2">
            <summary>A supported debug interface.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.DebugInterface.Port.COM3">
            <summary>A supported debug interface.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.DebugInterface.Port.COM4">
            <summary>A supported debug interface.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.DebugInterface.Port.USB1">
            <summary>A supported debug interface.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.Configuration.DebugInterface.Port.Sockets1">
            <summary>A supported debug interface (Ethernet for example).</summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.Configuration.Touch">
            <summary>
            Touch LCD configurations.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.Configuration.Touch.UseDefaultInterface(System.Boolean)">
            <summary>
            Enables/Disables default touch interface.
            </summary>
            <param name="enableDefault"><c>true</c> to use default interface.</param>
            <returns><c>true</c> if configurations where updated. <c>false</c> if configurations did not change.</returns>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.PWM">
            <summary>
            Provides PWM functionality.
            </summary>
            <remarks>
            Please refer to your platform documentation for the available PWM pins.<br/>
            <br/>
            <strong style="color:blue">USBizi</strong><br/>
            All PWM pins share the same timer. Changing one PWM frequency will affect the others.<br/>
            <br/>
            <strong style="color:blue">EMX</strong><br/>
            Some PWM pins share the same timer. Changing one PWM frequency will affect the others.<br/>
            PWM0 and PWM 2 share the same timer.<br/>
            PWM1, PWM3, PWM4 and PWM5 share the same timer.<br/>
            <br/>
            <strong style="color:blue">ChipworkX</strong><br/>
            Only one channel is available (0) with four frequencies: 391 KHz, 195 KHz, 98 KHz and 49 KHz.<br/>
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.PWM.Dispose">
            <summary>
            Disposes the pin and marks it as available again.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.PWM.Finalize">
            <exclude/>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.PWM.#ctor(GHIElectronics.NETMF.Hardware.PWM.Pin)">
            <summary>
            Creates a new PWM pin.
            </summary>
            <param name="pin">Needed pin.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.PWM.Set(System.Int32,System.Byte)">
            <summary>
            Sets the PWM's frequency and duty cycle.
            </summary>
            <param name="freq_Hz">Required frequency in Hertz.</param>
            <param name="dutyCycle">Duty cycle percentage. 0 to 100 inclusive.</param>
            <remarks>
            Setting the frequency to 0 would stop the PWM.<br/>
            0% and 100% are valid values for the duty cycle.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.PWM.Set(System.Boolean)">
            <summary>
            Sets the PWM pin as high or low.
            </summary>
            <param name="pinState"><c>true</c> if high.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.PWM.SetPulse(System.UInt32,System.UInt32)">
            <summary>
            Sets the PWM using the period time and high time.
            </summary>
            <param name="period_nanosecond">Period of the signal in nano seconds.</param>
            <param name="highTime_nanosecond">High time of the signal in nano seconds.</param>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.PWM.Pin">
            <summary>
            Lists the PWM pins.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM0">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM1">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM2">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM3">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM4">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM5">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM6">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM7">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM8">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM9">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM10">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM11">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM12">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM13">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM14">
            <summary>PWM pin.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.PWM.Pin.PWM15">
            <summary>PWM pin.</summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.BatteryRAM">
            <summary>
            Battery powered general purpose RAM.
            </summary>
            <remarks>
            This is a general purpose RAM that is powered using a backup battery. Therefore, it does not lose the data when the power is off.<br/>
            It starts at address 0 and the size is platform dependant. Please refer to your platform user manual for details on requirements and connections.<br/>
            <br/>
            <strong style="color:blue">EMX and USBizi</strong><br/>
            The available size is 2 KB. They ONLY can be accessed (read/write) as 4 bytes multiple (starting address, offset and size).<br/>
            <br/>
            <strong style="color:blue">ChipworkX</strong><br/>
            The available size is 16 bytes. They ONLY can be accessed (read/write) as 4 bytes multiple (starting address, offset and size).
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.BatteryRAM.Write(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes to the Battery RAM.
            </summary>
            <param name="address">Starting address in the battery ram.</param>
            <param name="buffer">Buffer.</param>
            <param name="offset">Offset in Buffer.</param>
            <param name="count">Count of bytes.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.BatteryRAM.Read(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads from the Battery RAM.
            </summary>
            <param name="address">Starting address in the battery ram.</param>
            <param name="buffer">Buffer.</param>
            <param name="offset">Offset in Buffer.</param>
            <param name="count">Count of bytes.</param>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.OutputCompare">
            <summary>
            Provides output compare functionality.
            </summary>
            <remarks>
            This is available on any pin. It has a blocking option for fast accurate timings and a non-blocking option that uses interrupts. This doesn't use real hardware output compare. Therefore, it may not be 100% accurate. Also, there is a limit in how much time the pin can toggle. Values are platform dependent.<br/>
            </remarks>
            <example>
            Using output compare.
            <code>
<![CDATA[
// Let's create a signal which is low for 200 micro seconds, high for 300 micro seconds and then low for 200 micro seconds.
bool initValue1 = true; // pin is high
uint[] timings1 = new uint[]{200, 300, 200};
OutputCompare oc1 = new OutputCompare(myPin1, initValue1, 10);
oc1.Set(false, timings1, 0, 3, false);

// Let's create a PWM signal, that is high for 500 micro seconds and low for 300 micro seconds. Note the usage of the bufferRepeating option.
bool initValue2 = false; // pin is low
uint[] timings2 = new uint[] {500, 300};
OutputCompare oc2 = new OutputCompare(myPin2, initValue2, 2);
oc1.Set(true, timings2, 0, 2, true);
]]>
</code>
            Creating a UART transmitter.
            <code>
<![CDATA[
// The following will do a software UART, 8N1, 2400 baudrate.
const int MAX_TIMINGS_BUFFER_SIZE = 10;
OutputCompare oc = new OutputCompare(pin, true, MAX_TIMINGS_BUFFER_SIZE);
uint[] buffer = new uint[MAX_TIMINGS_BUFFER_SIZE];
const int BAUD_RATE = 2400;
const int BIT_TIME_US = 1 * 1000 * 1000 / BAUD_RATE;
int BYTE_TIME_MS = (int)System.Math.Ceiling((double)BIT_TIME_US * MAX_TIMINGS_BUFFER_SIZE / 1000);

void SendByte(byte b)
{
    bool currentPinState;
    int currentBufferIndex = 0;
    uint currentStateTiming;

    // start bit
    currentPinState = false;
    currentStateTiming = BIT_TIME_US;

    // data bits
    for (int i = 0; i < 8; i++) 
    {
        bool neededState = (b & (1 << i)) != 0;

        if (neededState != currentPinState)
        {
            buffer[currentBufferIndex] = currentStateTiming;
            currentStateTiming = BIT_TIME_US;
            currentPinState = neededState;
            currentBufferIndex++;
        }
        else
        {
            currentStateTiming += BIT_TIME_US;
        }
    }
    
    // stop bit
    if (currentPinState != true)
    {
        buffer[currentBufferIndex] = currentStateTiming;
        currentBufferIndex++;
    }

    // Use a non-blocking option ///////////////
    oc.Set(false, buffer, 0, currentBufferIndex, false);
    // wait till data is sent
    Thread.Sleep(BYTE_TIME_MS);
    ////////////////////////////

    // Note that if the blocking option is used, you can get more accurate timings and faster baudrates. Also, you can disable processor interrupts so data doesn't get corrupted when interrupts occur.
    // oc.SetBlocking(false, buffer, 0, currentBufferIndex, BIT_TIME_US, true);
}
]]>
</code>
            </example>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OutputCompare.Dispose">
            <summary>
            Disposes the pin and marks it as available again.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OutputCompare.#ctor(Microsoft.SPOT.Hardware.Cpu.Pin,System.Boolean,System.Int32)">
            <summary>
            Creates a new output compare pin.
            </summary>
            <param name="pin">Pin.</param>
            <param name="initialValue">Initial pin value.</param>
            <param name="MAX_TIMINGS_BUFFER_SIZE">Maximum number of non-blocking timings.</param>
            <remarks>
            <c>MAX_TIMINGS_BUFFER_SIZE</c> limits the number of non-blocking timings that are set. For example, if you set this value to 10, you can send between 0 and 10 toggle timings in the <c>Set</c> method.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OutputCompare.Finalize">
            <exclude/>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OutputCompare.Set(System.Boolean)">
            <summary>
            Sets the current pin state.
            </summary>
            <param name="pinState">Pin state.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OutputCompare.Set(System.Boolean,System.UInt32[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets pin state transition times. This is a non-blocking method.
            </summary>
            <param name="initialValue">Initial pin value.</param>
            <param name="timingsBuffer_us">Toggle timings.</param>
            <param name="bufferOffset">Offset.</param>
            <param name="bufferCount">Count.</param>
            <param name="bufferRepeating">State transitions loop again when done.</param>
            <remarks>
            First, the pin is set to <c>initialValue</c>. After <c>timingsBuffer_us[bufferOffset + 0]</c> micro seconds, the pin will toggle its state and so on until <c>bufferCount</c> is reached. When done, if <c>bufferRepeating</c> is <c>true</c>, the signal will get regenerated automatically.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OutputCompare.SetBlocking(System.Boolean,System.UInt32[],System.Int32,System.Int32,System.UInt32,System.Boolean)">
            <summary>
            Sets pin state transition times. This is a blocking method.
            </summary>
            <param name="initialValue">Initial pin value.</param>
            <param name="timingsBuffer_us">Toggle timings.</param>
            <param name="bufferOffset">Offset.</param>
            <param name="bufferCount">Count.</param>
            <param name="lastBitHoldTime_us">Holds the last pin state for this much time (without toggling the state) before returning to the user.</param>
            <param name="disableInterrupts"><c>true</c> to disable processor interrupts during this call in order to get accurate timings.</param>
            <remarks>
            First, the pin is set to <c>initialValue</c>. After <c>timingsBuffer_us[bufferOffset + 0]</c> micro seconds, the pin will toggle its state and so on until <c>bufferCount</c> is reached. When done, it will hold the last pin state for lastBitHoldTime_us micro seconds.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OutputCompare.SetBlocking(System.Boolean,System.UInt32[],System.Int32,System.Int32,System.UInt32,System.Boolean,System.UInt32)">
            <summary>
            Sets pin state transition times. This is a blocking method.
            </summary>
            <param name="initialValue">Initial pin value.</param>
            <param name="timingsBuffer_us">Toggle timings.</param>
            <param name="bufferOffset">Offset.</param>
            <param name="bufferCount">Count.</param>
            <param name="lastBitHoldTime_us">Holds the last pin state for this much time (without toggling the state) before returning to the user.</param>
            <param name="disableInterrupts"><c>true</c> to disable processor interrupts during this call in order to get accurate timings.</param>
            <param name="carrierFrequency_hz">If this is set, it will generate a carrier frequency. Note that this is generated using software and may not be fully accurate.</param>
            <remarks>
            First, the pin is set to <c>initialValue</c>. After <c>timingsBuffer_us[bufferOffset + 0]</c> micro seconds, the pin will toggle its state and so on until <c>bufferCount</c> is reached. When done, it will hold the last pin state for lastBitHoldTime_us micro seconds.<br/>
            This is intended for internal use by GHI.
            </remarks>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.OutputCompare.IsActive">
            <summary>
            Output Compare toggling active state. 
            </summary>
            <remarks>
            This flag is <c>true</c> when the OC is processing the timings buffer to toggle the pin.<br/>
            For example, assume the used toggle timings are [300, 500, 400] and OutputCompare.Set(...) is called then:<br/>
            <code>
            OutputCompare.Set(...);
            while(OutputCompare.IsActive) // This will be true for 300 + 500 + 400 micro seconds
            ;
            </code>
            </remarks>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.LowLevel.Register">
            <summary>
            Provide register access.
            </summary>
            <remarks>
            Addresses access might be restricted on certain platforms.<br/>
            <br/>
            <strong style="color:blue">EMX and USBizi</strong><br/>
            Denoting '[' as inclusive and ')' as exclusive, only register access (4 bytes) with the following address ranges are valid:<br/>
            [0x3FFFC000 to 0x3FFFC0A0),<br/>
            [0xE0000000 to 0xE0000014),<br/>
            [0xE0004000 to 0xE004C000),<br/>
            [0xE0068000 to 0xE0090000),<br/>
            [0xE01FC000 to 0xE0200000),<br/>
            [0xFFE00000 to 0xFFE00FF8],<br/>
            [0xFFE0C000 to 0xFFE10000],<br/>
            [0xFFE10000 to 0xFFE10030],<br/>
            [0xFFE10200 to 0xFFE103FC],<br/>
            [0xFFE10800 to 0xFFE10BFC],<br/>
            [0xFFE10C00 to 0xFFE10C2C].<br/>
            <br/>
            <strong style="color:blue">ChipworkX</strong><br/>
            No current restrictions.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.Register.#ctor(System.UInt32)">
            <summary>
            Creates a new register.
            </summary>
            <param name="address">Address.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.Register.Write(System.UInt32)">
            <summary>
            Writes a value to the register.
            </summary>
            <param name="value">Value to be written.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.Register.Read">
            <summary>
            Reads the register's value.
            </summary>
            <returns>Value of the register.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.Register.SetBits(System.UInt32)">
            <summary>
            Sets certain bits in the register using a mask.
            </summary>
            <param name="mask">Register value mask.</param>
            <remarks>
            Bits of value 1 in mask are set in the register.<br/>
            Bits of value 0 in mask are not changed.<br/>
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.Register.ClearBits(System.UInt32)">
            <summary>
            Clears certain bits in the register using a mask.
            </summary>
            <param name="mask">Register value mask.</param>
            <remarks>
            Bits of value 1 in mask are cleared in the register.<br/>
            Bits of value 0 in mask are not changed.<br/>
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.Register.ToggleBits(System.UInt32)">
            <summary>
            Toggles certain bits in the register using a mask.
            </summary>
            <param name="mask">Register value mask.</param>
            <remarks>
            Bits of value 1 in mask are toggled in the register.<br/>
            Bits of value 0 in mask are not changed.<br/>
            </remarks>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.RealTimeClock">
            <summary>
            Access to the internal Real Time Clock.
            </summary>
            <remarks>
            With Real Time Clock, you can keep track of date and time even if the power is off. The time is running using an external backup battery and can last for years.<br/>
            The RTC time is not related to the NETMF time. You have to set the time manually at startup, see examples.<br/>
            To verify that a valid time is stored (battery is still running), the user has to make some checks for validations. For example:<br/>
            - The battery can be monitored.<br/>
            - <c>RealTimeClock.GetTime()</c> might throw an exception because of incorrect time.<br/>
            - <c>RealTimeClock.GetTime()</c> will return infeasible dates that the user can check, such as, a date that is less than 2010.<br/>
            - Store a checksum in the <c>BatteryRAM</c>. The number will only be correct and stay the same if the connected battery is alive.<br/>
            <br/>
            Please refer to your platform user manual for details on requirements and hardware connections.<br/>
            </remarks>
            <example>
            <code>
<![CDATA[
using System;
using Microsoft.SPOT.Hardware;
using GHIElectronics.NETMF.Hardware;

namespace Example
{
    public class Program
    {
        public static void Main()
        {
            // To keep track of time, set it at the beginning of your application from the RTC.

            // If the time was never set before, set it to a certain date and time.
            bool timeValid = false;
            if (timeValid == false)  
                RealTimeClock.SetTime(new DateTime(2010, 03, 01, 12, 0, 0, 0));
            /////
            
            // You have to set NETMF time from RTC
            Utility.SetLocalTime(RealTimeClock.GetTime());
        }
    }
}
]]>
</code>
            </example>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.RealTimeClock.SetTime(System.DateTime)">
            <summary>
            Sets RTC.
            </summary>
            <param name="time">Date and time.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.RealTimeClock.GetTime">
            <summary>
            Gets RTC.
            </summary>
            <returns>Date and time.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.RealTimeClock.SetAlarm(System.DateTime)">
            <summary>
            Sets the alarm.
            </summary>
            <param name="time">Date and time.</param>
            <remarks>
            This feature lets the user specify an alarm time. This can be used to drive the ALARM pin high or wakeup the processor from hibernation.<br/>
            The alarm pin is an RTC controlled output. This is a 1.8 V pin. The pin goes low when the alarm time is specified. It goes HIGH when an RTC alarm is generated.<br/>
            The RTC can supply battery power to the ALARM pin and that can be used by external hardware to restore module power and resume operation.<br/>
            <br/>
            Only EMX and USBizi support this functionality.
            </remarks>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.RealTimeClock.IsTimeValid">
            <summary>
            RTC is valid if it was set before and still running using a charged battery.
            </summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.PinCapture">
            <summary>
            Captures the pin's digital waveform into a buffer.
            </summary>
            <remarks>
            This performs a simple Pin Capture. It <b>blocks</b> all the managed threads until a specified timeout is passed or the specified pin toggles count is reached.<br/>
            When the pin's state changes, the state, high or low, time is calculated and stored.<br/>
            <br/>
            The pin can be an <c>InputPort</c> or an <c>InterruptPort</c>. The underlying <c>Port</c> object can be obtained from this class and controlled directly.
            </remarks>
            <example>
            Assume the user specifies to capture three timings. The pin states were as follows:<br/>
            First pin state was high for 456 Microseconds.<br/> 
            Second pin state was low for 78 Microseconds.<br/> 
            Third pin state was high for 40 Microseconds.<br/> 
            The captured timings will be 456, 78 and 40.
            </example>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.PinCapture.#ctor(Microsoft.SPOT.Hardware.Cpu.Pin,Microsoft.SPOT.Hardware.Port.ResistorMode)">
            <summary>
            Constructor for input and interrupt pins.
            </summary>
            <param name="pin">Pin.</param>
            <param name="resistorMode">Resistor mode.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.PinCapture.#ctor(Microsoft.SPOT.Hardware.Cpu.Pin,Microsoft.SPOT.Hardware.Port.ResistorMode,Microsoft.SPOT.Hardware.Port.InterruptMode)">
            <summary>
            Constructor for interrupt pins only.
            </summary>
            <param name="pin">Pin.</param>
            <param name="resistorMode">Resistor mode.</param>
            <param name="interruptMode">Interrupt mode.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.PinCapture.Read(System.Boolean@,System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Reads the pin's waveform. The method stores the initial state for the user.
            </summary>
            <param name="initialState">The initial state of the pin.</param>
            <param name="buffer">Buffer holds the pin toggle times in microseconds.</param>
            <param name="offset">Offset.</param>
            <param name="count">Count.</param>
            <param name="timeout">Timeout in milliseconds.</param>
            <returns>Number of pin toggles.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.PinCapture.Read(System.Boolean,System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Reads the pin's waveform after waiting for an initial state.
            </summary>
            <param name="waitForState">Waits for this pin state before starting the capture.</param>
            <param name="buffer">The buffer holds the pin toggle times in microseconds.</param>
            <param name="offset">Offset.</param>
            <param name="count">Count.</param>
            <param name="timeout">Timeout in milliseconds.</param>
            <returns>Number of pin toggles.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.PinCapture.Dispose">
            <summary>
            Disposes the pin and marks it as available.
            </summary>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.PinCapture.InternalPort">
            <summary>
            Gets the underlying <c>Port</c> object for this pin.
            </summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.ParallelPort">
            <summary>
            Provides ParallelPort functionality.
            </summary>
            <remarks>
            This class controls multiple pins at the same time. The data is written and/or read by using 8 data pins.<br/>
            The pins can be any I/Os available on the used platform.<br/>
            When writing to the ParallelPort, the write pin is pulsed after each byte to signal that data is ready. The write pin is required for writing operation.<br/>
            When reading from the ParallelPort, the read pin is pulsed before each byte to signal that data will be read. The read pin is required for reading operation.<br/>
            <br/>
            On USBizi, a special handling is done if using a certain set of pins. The writing is optimized in this case and it will be about 16 times faster. The pins are as follows:<br/>
            Special data pins must be, starting from LSb, [IO61, IO62, IO63, IO64, IO65, IO21, IO66, IO67] and write pin must be IO56.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.ParallelPort.#ctor(Microsoft.SPOT.Hardware.Cpu.Pin[],Microsoft.SPOT.Hardware.Cpu.Pin,Microsoft.SPOT.Hardware.Cpu.Pin)">
            <summary>
            Creates a new ParallelPort.
            </summary>
            <param name="dataPins">Must be valid 8 data pins. dataPins[0] corresponds to data bit 0 and so on.</param>
            <param name="writePin">This pin must be provided for writing. If you are not writing and only reading, set this pin to <c>Cpu.Pin.GPIO_NONE</c>. The pin is active low.</param>
            <param name="readPin">This pin must be provided for reading. If you are not reading and only writing, set this pin to <c>Cpu.Pin.GPIO_NONE</c>. The pin is active low.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.ParallelPort.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes data to the ParallelPort.
            </summary>
            <param name="data">Data buffer.</param>
            <param name="offset">Offset.</param>
            <param name="count">Count.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.ParallelPort.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads data from the ParallelPort.
            </summary>
            <param name="data">Data buffer.</param>
            <param name="offset">Offset.</param>
            <param name="count">Count.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.ParallelPort.Dispose">
            <summary>
            Disposes the ParallelPort and all used pins.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.ParallelPort.Finalize">
            <exclude />
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.OneWire">
            <summary>
            Provides 1-Wire functionality.
            </summary>
            <remarks>
            One Wire communications can be done on any available pin. 
            </remarks>
            <example>
            The following example is used with Maxim Digital Thermometer DS18B20.<br/>
            It assumes only one slave is connected to the 1-wire bus and the DS18B20 is powered by an external power supply on VDD.
            <code>
<![CDATA[
using System;
using System.Threading;

using Microsoft.SPOT;
using Microsoft.SPOT.Hardware;

using GHIElectronics.NETMF.Hardware;

namespace Test
{
    public class Program
    {
        public static void Main()
        {
            // Change this your correct pin!
            Cpu.Pin myPin = (Cpu.Pin)2;

            OneWire ow = new OneWire(myPin);
            ushort temperature;

            // read every second
            while (true)
            {
                if (ow.Reset())
                {
                    ow.WriteByte(0xCC);     // Skip ROM
                    ow.WriteByte(0x44);     // Start temperature conversion

                    while (ow.ReadByte() == 0)
                        ;   // wait while busy

                    ow.Reset();
                    ow.WriteByte(0xCC);     // skip ROM
                    ow.WriteByte(0xBE);     // Read Scratchpad

                    temperature = ow.ReadByte();       // LSB 
                    temperature |= (ushort)(ow.ReadByte() << 8); // MSB

                    Debug.Print("Temperature: " + temperature / 16);
                    Thread.Sleep(1000);
                }
                else
                {
                    Debug.Print("Device is not detected.");
                }

                Thread.Sleep(1000);
            }
        }
    }
}
]]>
</code>
            </example>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.Dispose">
            <summary>
            Disposes the 1-wire pin and marks it as available again.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.Finalize">
            <exclude />
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.#ctor(Microsoft.SPOT.Hardware.Cpu.Pin)">
            <summary>
            Constructor.
            </summary>
            <param name="pin">Pin.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.CalculateCRC(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Calculates 8-bit CRC using 1-wire specification.
            </summary>
            <param name="buffer">Buffer.</param>
            <param name="offset">Offset.</param>
            <param name="count">Count.</param>
            <returns>CRC.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.CalculateCRC16(System.Byte[],System.Int32,System.Int32,System.UInt16)">
            <summary>
            Calculates 16-bit CRC using 1-wire specification.
            </summary>
            <param name="buffer">Buffer.</param>
            <param name="offset">Offset.</param>
            <param name="count">Count.</param>
            <param name="seed">CRC seed.</param>
            <returns>CRC.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.Reset">
            <summary>
            Resets 1-wire bus.
            </summary>
            <returns><c>true</c> if devices are detected.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.WriteBit(System.Byte)">
            <summary>
            Writes one bit.
            </summary>
            <param name="value">Writes LSb.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.ReadBit">
            <summary>
            Reads one bit.
            </summary>
            <returns>The bit is stored as LSb.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.WriteByte(System.Byte)">
            <summary>
            Writes a byte.
            </summary>
            <param name="value">value.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.ReadByte">
            <summary>
            Reads a byte.
            </summary>
            <returns>value.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a block of bytes.
            </summary>
            <param name="buffer">Buffer.</param>
            <param name="offset">Offset.</param>
            <param name="count">Count.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a block of bytes.
            </summary>
            <param name="buffer">Buffer.</param>
            <param name="offset">Offset.</param>
            <param name="count">Count.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.Search_Restart">
            <summary>
            Restarts devices search on 1-wire bus.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.Search_GetNextDevice(System.Byte[])">
            <summary>
            Gets next available 1-wire device.
            </summary>
            <remarks>
            This method obtains the next available 8-byte unique ROM Registration Number. 
            </remarks>
            <param name="romRegistrationNumber">ROM Registration Number. The provided buffer size must be at least 8 bytes.</param>
            <returns><c>true</c> if next device found.<br></br><c>false</c> if no more devices are available.</returns>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.OneWire.Search_IsDevicePresent(System.Byte[])">
            <summary>
            Detects device presence.
            </summary>
            <remarks>
            Detects if the device with provided ROM Registration Number exists.
            </remarks>
            <param name="romRegistrationNumber">ROM Registration Number. The buffer size must be at least 8 bytes.</param>
            <returns><c>true</c> if device found.</returns>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.LowLevel.Watchdog">
            <summary>
            Provides Watchdog functionality.
            </summary>
            <remarks>
            Watchdog is used to reset the system if it enters an erroneous state. The Watchdog is enabled with a specified timeout. The user must keep resetting the Watchdog time counter within this timeout interval or otherwise the system will reset.<br/>
            <c>Watchdog.LastResetCause</c> gives you information about the last known reset cause. Note that this flag is automatically reset after it is read.<br/>
            <br/>
            This should only be  used by advanced users.<br/>
            <br/>
            <strong style="color:blue">EMX and USBizi</strong><br/>
            <strong>Note: </strong> Once the Watchdog is enabled, it cannot be disabled.<br/>
            <br/>
            <strong style="color:blue">ChipworkX</strong><br/>
            <strong>Note: </strong> Once the Watchdog is enabled, it cannot be disabled. Also, it cannot be re-enabled with a different timeout.<br/>
            </remarks>
            <example>
            This example will reset the system if it becomes unresponsive. This is determined when the C# thread that resets the Watchdog time counter is not working anymore.
            <code>
<![CDATA[
using System.Threading;
using GHIElectronics.NETMF.Hardware.LowLevel;

namespace Example
{
    public class Program
    {
        public static void Main()
        {
            // Timeout 5 seconds
            uint timeout = 1000 * 5;

            // Enable Watchdog
            Watchdog.Enable(timeout);

            // Start a time counter reset thread
            WDTCounterReset = new Thread(WDTCounterResetLoop);
            WDTCounterReset.Start();

            // ....

            // If we exit the program, the thread will stop working and the system will reset!
            Thread.Sleep(Timeout.Infinite);
        }

        static Thread WDTCounterReset;
        static void WDTCounterResetLoop()
        {
            while (true)
            {
                // reset time counter every 3 seconds
                Thread.Sleep(3000);

                Watchdog.ResetCounter();
            }
        }
    }
}
]]>
</code>
            </example>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.Watchdog.Enable(System.UInt32)">
            <summary>
            Enables the Watchdog.
            </summary>
            <param name="timeout_ms">Timeout in milli-seconds.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.Watchdog.Disable">
            <summary>
            Disables the Watchdog.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.LowLevel.Watchdog.ResetCounter">
            <summary>
            Resets the Watchdog time counter.
            </summary>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.LowLevel.Watchdog.LastResetCause">
            <summary>
            Last known reset cause.
            </summary>
            <remarks>
            This can be used for troubleshooting when the system resets. Note that this flag is automatically reset after it is read.<br/>
            <br/>
            <strong style="color:blue">EMX and USBizi</strong><br/>
            Works correctly.<br/>
            <br/>
            <strong style="color:blue">ChipworkX</strong><br/>
            Currently not supported.
            </remarks>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.LowLevel.Watchdog.MAX_TIMEOUT">
            <summary>
            Maximum supported timeout.
            </summary>
            <remarks>
            Value is platform dependant.
            </remarks>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.LowLevel.Watchdog.ResetCause">
            <summary>
            Cause of system reset.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.LowLevel.Watchdog.ResetCause.HardReset">
            <summary>
            Hard reset.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.LowLevel.Watchdog.ResetCause.WatchdogReset">
            <summary>
            Reset because of the Watchdog timer elapsing.
            </summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.AnalogOut">
            <summary>
            Provides the ability to set a value to an analog output pin.
            </summary>
            <remarks>
            Please refer to your platform documentation for the available analog pins. The analog pin is initialized with the default platform resolution.<br/>
            <br/>
            <strong style="color:blue">EMX and USBizi</strong><br/>
            Only one channel is available (0). Default resolution is 10 bits with analog value between [0, 1023].
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.AnalogOut.Dispose">
            <summary>
            Disposes the pin and marks it as available again.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.AnalogOut.Finalize">
            <exclude/>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.AnalogOut.#ctor(GHIElectronics.NETMF.Hardware.AnalogOut.Pin)">
            <summary>
            Creates a new analog pin.
            </summary>
            <param name="aout">Needed analog pin.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.AnalogOut.SetLinearScale(System.Int32,System.Int32)">
            <summary>
            Scales the analog value, when it is set, automatically into a specific range.
            </summary>
            <param name="minValue">Min value.</param>
            <param name="maxValue">Max value.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.AnalogOut.Set(System.Int32)">
            <summary>
            Sets the current analog value.
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.AnalogOut.Set(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets analog output values at a given rate.
            </summary>
            <param name="data">Data.</param>
            <param name="offset">Data offset.</param>
            <param name="count">Data count.</param>
            <param name="dataRate">Data rate in Hertz.</param>
            <remarks>
            Use this to output values at a give rate. The analog output will be set to the first value for a duration of (1 / dataRate). Then it will be set to the second value and so on.<br/>
            Note that this method is blocking. It returns when the data count is done.
            </remarks>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.AnalogOut.Pin">
            <summary>
            Lists the analog output pins.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.AnalogOut.Pin.Aout0">
            <summary>Analog output pin.</summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.CANErrorReceivedEventArgs">
            <summary>
            CAN error received event arguments.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.CANErrorReceivedEventArgs.#ctor(GHIElectronics.NETMF.Hardware.CAN.Error)">
            <summary>
            Constructor.
            </summary>
            <param name="Error">CAN error.</param>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CANErrorReceivedEventArgs.Error">
            <summary>
            Associated error with this event.
            </summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.CANDataReceivedEventArgs">
            <summary>
            CAN data received event arguments.
            </summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.CANDataReceivedEventHandler">
            <summary>
            CAN data received event handler.
            </summary>
            <param name="sender">CAN sender.</param>
            <param name="args">Event arguments.</param>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.CANErrorReceivedEventHandler">
            <summary>
            CAN error received event handler.
            </summary>
            <param name="sender">CAN sender.</param>
            <param name="args">Event arguments.</param>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.CAN">
            <summary>
            Provides Controller Area Network (CAN) functionality.
            </summary>
            <remarks>
            Controller Area Network (CAN) is a common network in the automotive industry. This class provides functions to read/write messages, Get events for incoming data or errors, and set filters on messages' IDs.<br/>
            <br/>
            <strong style="color:blue">Platform Support</strong><br/>
            CAN is only supported on EMX and USBizi.<br/>
            <br/>
            <strong style="color:blue">Using CAN</strong><br/>
            CAN is constructed using the channel number and the bitrate. Note that the bitrate defines the timings needed and must be set as provided in the example section.<br/>
            Since processing all incoming messages is important, there is an optional <c>receiveBufferSize</c> argument. You can increase the number of bufferd messages to make sure the application can process all of them. Also, it is recommended to use the filters.<br/>
            <br/>
            Messages are read using <c>GetMessages(...)</c>. This method is optimized for batch reading. The more messages read, the faster it will be versus reading them individually. Event are sent when messages are available. Also, <c>ReceivedMessagesCount</c> provides the number of available messages.<br/>
            <br/>
            Messages are written using <c>PostMessages(...)</c>. The messages are queued for transmission. <c>PostedMessagesSent</c> specifies whether all messages are transmitted.<br/>
            <br/>
            <strong style="color:blue">CAN Errors</strong><br/>
            CAN errors are sent as events to the user using <c>ErrorReceivedEvent</c>. <c>RXOver</c> error is sent when the input buffer is full and a message is lost. In this case, you can increase the receive buffer size in the CAN constructor and use the CAN filters. Another important error is <c>BusOff</c>. When this error occurs, the CAN controller is stopeed from further communications. To enable the controller again, use <c>CAN.Reset</c>.<br/>
            Also, there are error counters: <c>ReceiveErrorCount</c> and <c>TransmitErrorCount</c>.<br/>
            <br/>
            <strong style="color:blue">CAN Filters</strong><br/>
            Software filters for messages' IDs are supported for exact and group matches. One of them or both can be used at the same time. Exact matches are done using <c>SetExplicitFilters</c>. Only messages with identifiers included in these filters will pass through to the receive buffer. Group identifiers defines a group (range) or more of messages that are filtered using <c>SetGroupFilters</c>. Only messages with identifiers between a lower bound and an upper bound are passed to the receive buffer. Searching through software filters is done natively and highly optimized.<br/>
            Hardware filters are not directly supported but can be set using registers (<c>Register</c> class). You can set explicit or group identifiers for each CAN controller. For complete details, please see LPC24xx User Manual.<br/>
            A combination of software and hardware filters can be used.<br/>
            </remarks>
            <example>
            The following demonstrates how to use the CAN class.
            <code>
<![CDATA[
using System;
using System.Threading;
using Microsoft.SPOT;
using Microsoft.SPOT.Hardware;
using GHIElectronics.NETMF.Hardware;

namespace Example
{
    public class Program
    {
        // Messages list
        static CAN.Message[] msgList;

        public static void Main()
        {
            // Set the system time. CAN messages will have a time stamp
            Utility.SetLocalTime(new DateTime(2011, 2, 14, 0, 0, 0));

            int T1, T2, BRP;

            // These numbers were calculated using the calculator on this link:
            // http://www.kvaser.com/can/protocol/index.htm
            // We used the very first value from the calculator output

            /////////////////////////////////////////////////////////////////////////////////////////////
            // Bitrate 250Kbps
            // CLK = 72 Mhz, with BRP = 12 -> 6Mhz CAN clock
            // 6Mhz/250Kbps = 24 TQ
            // T1 = 16 minus 1 for sync = 15
            // T2 = 8
            // 15 + 1 + 8 = 24 TQs which is what we need
            /////////////////////////////////////////////////////////////////////////////////////////////
            // uncomment to use this bit timing
            //BRP = 12;
            //T1 = 15;
            //T2 = 8;

            /////////////////////////////////////////////////////////////////////////////////////////////
            // Bitrate 125Kbps
            // CLK = 72 Mhz, with BRP = 24 -> 3Mhz CAN clock
            // 3Mhz/125Kbps = 24 TQ
            // T1 = 16 minus 1 for sync = 15
            // T2 = 8
            // 15 + 1 + 8 = 24 TQs which is what we need
            /////////////////////////////////////////////////////////////////////////////////////////////
            // uncomment to use this bit timing
            BRP = 24;
            T1 = 15;
            T2 = 8;

            // For 500Kbps you can use BRP=6 and for 1Mbps you can use BRP=3 ...and so on

            // Use channel 1
            CAN can = new CAN(CAN.Channel.Channel_1, (uint)(((T2 - 1) << 20) | ((T1 - 1) << 16) | ((BRP - 1) << 0)));

            // create a message list of 100 messages
            msgList = new CAN.Message[100];
            for (int i = 0; i < msgList.Length; i++)
                msgList[i] = new CAN.Message();

            /*
            // example for sending one message
            // msg ID
            msgList[0].ArbID = 0x55;
            msgList[0].Data[0] = 1;
            msgList[0].Data[1] = 2;
            msgList[0].Data[2] = 3;
            msgList[0].Data[3] = 4;
            msgList[0].Data[4] = 5;
            msgList[0].Data[5] = 6;
            msgList[0].Data[6] = 7;
            msgList[0].Data[7] = 8;
            // Send the 8 bytes for example
            msgList[0].DLC = 8;
            msgList[0].IsEID = false;
            msgList[0].IsRTR = false;
            // Send one messages
            int numberOfMessagesPosted = can.PostMessages(msgList, 0, 1);
            */

            // subscribe to events
            can.DataReceivedEvent += new CANDataReceivedEventHandler(can_DataReceivedEvent);
            can.ErrorReceivedEvent += new CANErrorReceivedEventHandler(can_ErrorReceivedEvent);

            // sleep forever
            Thread.Sleep(Timeout.Infinite);
        }

        static void can_DataReceivedEvent(CAN sender, CANDataReceivedEventArgs args)
        {
            Debug.Print(">>> can_DataReceivedEvent <<<");

            // read as many messages as possible
            int count = sender.GetMessages(msgList, 0, msgList.Length);
            for (int i = 0; i < count; i++)
            {
                Debug.Print("MSG: ID = " + msgList[i].ArbID + " at time = " + msgList[i].TimeStamp);
            }
        }

        static void can_ErrorReceivedEvent(CAN sender, CANErrorReceivedEventArgs args)
        {
            Debug.Print(">>> can_ErrorReceivedEvent <<<");

            switch (args.Error)
            {
                case CAN.Error.Overrun:
                    Debug.Print("Overrun error. Message lost");
                    break;

                case CAN.Error.RXOver:
                    Debug.Print("RXOver error. Internal buffer is full. Message lost");
                    break;

                case CAN.Error.BusOff:
                    Debug.Print("BusOff error. Reset CAN controller.");
                    sender.Reset();
                    break;
            }
        }
    }
}
]]>
</code>
            </example>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.CAN.SetExplicitFilters(System.UInt32[])">
            <summary>
            Sets explicit filters.
            </summary>
            <param name="filters">Messages' IDs to filter.</param>
            <remarks>
            This filters exact matches for message identifiers (standard or extended). The provided filters will be copied internally and searched using an optimized software search.<br/>
            For example, to only receive messages with these IDs (0x1234, 0x5789, 0x12345678), do the following:<br/>
            <code>
            uint[] explicitIDs = new uint[] {0x1234, 0x5789, 0x12345678};
            can.SetExplicitFilters(explicitIDs);
            </code>
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.CAN.SetGroupFilters(System.UInt32[],System.UInt32[])">
            <summary>
            Sets group (range) filters.
            </summary>
            <param name="lowerBounds">Group lower bounds for messages' IDs to filter. Each lower bound corresponds to an upper bound.</param>
            <param name="upperBounds">Group upper bounds for messages' IDs to filter. Each upper bound corresponds to a lower bound.</param>
            <remarks>
            This filters a group (range) of message identifiers (standard or extended). The provided filters will be copied internally and searched using an optimized software search.<br/>
            Every pair of a lower bound at index i and an upper bound at the same index defines a valid group. The provided groups MUST not overlap. Otherwise, the method will throw an argument exception.<br/>
            For example, to only receive messages with these two groups of IDs [0x1200 to 0x1248] and [0x500 to 0x1000], do the following:<br/>
            <code>
            uint[] lowerBounds = new uint[] { 0x1200, 0x500 };
            uint[] upperBounds = new uint[] { 0x1248, 0x1000 };
            can.SetGroupFilters(lowerBounds, upperBounds);
            </code>
            Note that the bounds' limits are considered valid. In the above example, 0x1200, 0x1248, 0x500 and 0x1000 are valid IDs and will pass through to the receive buffer.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.CAN.DisableExplicitFilters">
            <summary>
            Disables the explicit filters.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.CAN.DisableGroupFilters">
            <summary>
            Disables the group filters.
            </summary>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.CAN.#ctor(GHIElectronics.NETMF.Hardware.CAN.Channel,System.UInt32)">
            <summary>
            Initializes CAN.
            </summary>
            <param name="channel">Channel.</param>
            <param name="bitrate">Bitrate. Refer to provided the example.</param>
            <remarks>
            For bitrate calculation, please see the provided example.<br/>
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.CAN.#ctor(GHIElectronics.NETMF.Hardware.CAN.Channel,System.UInt32,System.Int32)">
            <summary>
            Initializes CAN.
            </summary>
            <param name="channel">Channel.</param>
            <param name="bitrate">Bitrate. Refer to provided the example.</param>
            <param name="receiveBufferSize">Specifies the receive buffer size (number of internally buffered CAN messages).</param>
            <remarks>
            For bitrate calculation, please see the provided example.<br/>
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.CAN.Reset">
            <summary>
            Resets the CAN controller.
            </summary>
            <remarks>
            This methods resets the CAN controller. This is needed in the Bus Off condition because the controller get disabled automatically.<br/>
            Note that a reset causes the hardware buffered messages to be lost (On EMX and USBizi, this is 2 for receive and 3 for transmit). The software receive buffer is not affected. The software filters are not affected either.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.CAN.GetMessages(GHIElectronics.NETMF.Hardware.CAN.Message[],System.Int32,System.Int32)">
            <summary>
            Receives CAN messages.
            </summary>
            <param name="msg">User provided messages buffer.</param>
            <param name="offset">Offset into the buffer.</param>
            <param name="count">Number of messages to read.</param>
            <returns>Number of read messages.</returns>
            <remarks>
            This methods reads messages, if available, and returns how many messages it was able to read.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.CAN.PostMessages(GHIElectronics.NETMF.Hardware.CAN.Message[],System.Int32,System.Int32)">
            <summary>
            Posts (queues for writing) CAN messages.
            </summary>
            <param name="msg">User provided messages buffer.</param>
            <param name="offset">Offset into the buffer.</param>
            <param name="count">Number of messages to write.</param>
            <returns>Number of written messages.</returns>
            <remarks>
            This methods writes as many messages as possible until the internal buffers are full. The user MUST check the return value to see how many messages were written.
            </remarks>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.CAN.Finalize">
            <exclude/>
        </member>
        <member name="M:GHIElectronics.NETMF.Hardware.CAN.Dispose">
            <summary>
            Disposes CAN.
            </summary>
        </member>
        <member name="E:GHIElectronics.NETMF.Hardware.CAN.DataReceivedEvent">
            <summary>
            Data received event.
            </summary>
            <remarks>
            The event will fire only once when CAN messages are received. Then the user can read as many CAN messages as possible. If there are more unread messages, the event will fire again automatically.
            </remarks>
        </member>
        <member name="E:GHIElectronics.NETMF.Hardware.CAN.ErrorReceivedEvent">
            <summary>
            Error received event.
            </summary>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.CAN.ReceiveErrorCount">
            <summary>
            CAN receive error count.
            </summary>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.CAN.TransmitErrorCount">
            <summary>
            CAN transmit error count.
            </summary>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.CAN.ReceivedMessagesCount">
            <summary>
            The number of messages ready to be read.
            </summary>
        </member>
        <member name="P:GHIElectronics.NETMF.Hardware.CAN.PostedMessagesSent">
            <summary>
            A boolean value denoting if all posted (queued for writing) messages are sent.
            </summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.CAN.Error">
            <summary>
            CAN errors.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CAN.Error.Overrun">
            <summary>
            A CAN message is lost because the hardware was not able to receive the message in time.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CAN.Error.RXOver">
            <summary>
            A CAN message is lost because the receive buffer is full. Try increasing the receive message buffer in the CAN constructor and use CAN filters.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CAN.Error.BusOff">
            <summary>
            CAN Bus Off condition. Note that the controller is disabled in this case. Use <c>CAN.Reset()</c> to re-enable it.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CAN.Error.ErrorPassive">
            <summary>
            Error passive condition.
            </summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.CAN.Channel">
            <summary>
            Lists the available CAN channels.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CAN.Channel.Channel_1">
            <summary>CAN channel.</summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CAN.Channel.Channel_2">
            <summary>CAN channel.</summary>
        </member>
        <member name="T:GHIElectronics.NETMF.Hardware.CAN.Message">
            <summary>
            CAN message.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CAN.Message.Data">
            <summary>
            The CAN message data.
            </summary>
            <remarks>
            The message data is a maximum of 8 bytes. The user store data directly before trasmitting.<br/>
            When receiving data, the user can read this field directly.
            </remarks>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CAN.Message.ArbID">
            <summary>
            CAN message ID.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CAN.Message.DLC">
            <summary>
            CAN message data count.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CAN.Message.IsRTR">
            <summary>
            Specifies if the message is RTR (Remote Transmission Request).
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CAN.Message.IsEID">
            <summary>
            Specifies if the message is EID (Extended ID - 29 bit identifier). Otherwise, it is 11 bit identifier.
            </summary>
        </member>
        <member name="F:GHIElectronics.NETMF.Hardware.CAN.Message.TimeStamp">
            <summary>
            Received message time stamp.
            </summary>
        </member>
    </members>
</doc>
